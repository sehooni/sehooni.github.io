const fs = require('fs');
const path = require('path');
const matter = require('gray-matter');

const postsDirectory = path.join(process.cwd(), 'content/posts');
const publicDirectory = path.join(process.cwd(), 'out'); // Next.js exports to 'out', but we might need to put it in public if running before build?
// Actually, usually we generate into public/ so it gets copied to out/ during build, OR we generate directly into out/ post-build.
// The plan is to run this as part of build. Let's write to 'public' first so Next.js handles it, OR if running post-build, write to 'out'.
// Ideally, run BEFORE build so it's in public and gets copied? Or AFTER build into out.
// Let's write to 'public' and run it before 'next build' or make sure it's available.
// BUT, if we run it as part of "build" script "node generate-rss.js && next build", then public is correct.
// If we run "next build && node generate-rss.js", then we must write to 'out'.
// Let's target 'out' because we are modifying the build script to be safe.
// Wait, if I write to public, I might dirty the repo if not ignored.
// Let's write to './public/feed.xml' AND ensure we run it *before* the build if we want Next to copy it? 
// No, simpler: user approved "node scripts/generate-rss.js" in build process.
// Let's modify package.json to: "prebuild": "node scripts/generate-post-map.js && node scripts/generate-rss.js"
// Then Next.js build will pick it up from public/.

const RSS_FILE = path.join(process.cwd(), 'public', 'feed.xml');
const SITE_URL = 'https://sehooni.github.io';

const allPosts = [];

function traverseDirectory(dir) {
    const files = fs.readdirSync(dir);
    for (const file of files) {
        const fullPath = path.join(dir, file);
        const stat = fs.statSync(fullPath);

        if (stat.isDirectory()) {
            traverseDirectory(fullPath);
        } else if (file.endsWith('.md')) {
            const relativeDir = path.relative(postsDirectory, dir);
            const category = relativeDir || 'uncategorized';

            const fileName = file.replace(/\.md$/, '');
            const titleMatch = fileName.match(/^\d{4}-\d{2}-\d{2}-(.*)$/);
            const titleSlug = titleMatch ? titleMatch[1] : fileName;

            // Reconstruct logic from lib/posts.ts roughly to match URLs
            const categorySegments = category !== 'uncategorized' ? category.split(path.sep) : ['uncategorized'];
            // Simplify URL construction: baseUrl / category / titleSlug (lowercase?) 
            // In posts.ts: slugArray = [...categorySegments, titleSlug]. 
            // We need to match the EXACT URL format generated by sitemap.ts.
            // sitemap.ts uses: ${baseUrl}/${post.slug}/

            const fileContents = fs.readFileSync(fullPath, 'utf8');
            const matterResult = matter(fileContents);

            let date = matterResult.data.date;
            if (date instanceof Date) {
                date = date.toISOString();
            } else if (!date) {
                const match = file.match(/^(\d{4}-\d{2}-\d{2})/);
                if (match) {
                    date = new Date(match[1]).toISOString();
                }
            }

            // Slug construction
            // NOTE: We must match the slug generation logic from lib/posts.ts exactly.
            // In lib/posts.ts: const slugArray = [...categorySegments, titleSlug]; const slug = slugArray.join('/');
            const slug = [...categorySegments, titleSlug].join('/');
            const url = `${SITE_URL}/${slug}/`;

            allPosts.push({
                title: matterResult.data.title || titleSlug,
                date: date || new Date().toISOString(),
                description: matterResult.data.excerpt || matterResult.data.description || '',
                url: url,
                guid: url
            });
        }
    }
}

traverseDirectory(postsDirectory);

// Sort by date desc
allPosts.sort((a, b) => new Date(b.date) - new Date(a.date));

const xmlItems = allPosts.map(post => {
    return `
    <item>
      <title><![CDATA[${post.title}]]></title>
      <link>${post.url}</link>
      <guid>${post.guid}</guid>
      <pubDate>${new Date(post.date).toUTCString()}</pubDate>
      <description><![CDATA[${post.description}]]></description>
    </item>`;
}).join('');

const rssXml = `<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sehoon's Blog</title>
    <link>${SITE_URL}</link>
    <description>Sehoon's Technical Blog</description>
    <language>ko</language>
    <lastBuildDate>${new Date().toUTCString()}</lastBuildDate>
    <atom:link href="${SITE_URL}/feed.xml" rel="self" type="application/rss+xml" />
    ${xmlItems}
  </channel>
</rss>`;

fs.writeFileSync(RSS_FILE, rssXml);
console.log(`RSS feed generated at ${RSS_FILE}`);
